# 8. 对象、类与面向对象编程

## 理解对象

### 属性的类型

1. 数据属性

- \[[Configurable]]：表示属性是否可以通过 delete 删除并重新定义，是否可以修改它的特性，以及是否可以把它改为访问器属性。默认 true
- \[[Enumerable]]：表示属性是否可以通过 for-in 循环返回。默认 true
- \[[Writable]]：表示属性的值是否可以被修改。默认 true
- \[[Value]]：包含属性实际的值。默认 undefined

`Object.defineProperty()`方法修改属性默认特性，接受三个参数：要给其添加属性的对象、属性的名称、一个描述符对象

```js
// configurable、enumerable 和 writable 的值如果不指定，则都默认为 false
let person = {};
Object.defineProperty(person, 'name', {
  configurable: false,
  value: 'Nicholas',
});
console.log(person.name); // "Nicholas"
delete person.name;
console.log(person.name); // "Nicholas"

// 一个属性被定义为不可配置之后，就不能再变回可配置的了。再次调用 Object.defineProperty()并修改任何非 writable 属性会导致错误
// 抛出错误
Object.defineProperty(person, 'name', {
  configurable: true,
  value: 'Nicholas',
});
```

2. 访问器属性

访问器属性只能通过 Object.defineProperty()函数定义

- \[[Configurable]]：表示属性是否可以通过 delete 删除并重新定义，是否可以修改它的特性，以及是否可以把它改为访问器属性。默认 true
- \[[Enumerable]]：表示属性是否可以通过 for-in 循环返回。默认 true
- \[[Get]]：获取函数，在读取属性时调用。默认值为 undefined
- \[[Set]]：设置函数，在写入属性时调用。默认值为 undefined

### 定义多个对象

```js
let book = {};
Object.defineProperties(book, {
  year_: {
    value: 2017,
  },
  edition: {
    value: 1,
  },
  year: {
    get() {
      return this.year_;
    },
    set(newValue) {
      if (newValue > 2017) {
        this.year_ = newValue;
        this.edition += newValue - 2017;
      }
    },
  },
});
```

### 读取属性的特性

`Object.getOwnPropertyDescriptor()`和`Object.getOwnPropertyDescriptors()`获取对象属性的属性描述符

```js
let book = {};
Object.defineProperties(book, {
  edition: {
    value: 1,
  },
  year: {
    get: function () {
      return this.year_;
    },
    set: function (newValue) {
      if (newValue > 2017) {
        this.year_ = newValue;
        this.edition += newValue - 2017;
      }
    },
  },
});
console.log(Object.getOwnPropertyDescriptors(book));
// {
// year: {
// configurable: false,
// enumerable: false,
// get: f(),
// set: f(newValue),
// },
// year_: {
// configurable: false,
// enumerable: false,
// value: 2017,
// writable: false
// }
// }
```

### 合并对象

`Object.assign()`：接受一个目标对象和`多个源对象作为参数`（将每个源对象中可枚举（Object.propertyIsEnumerable()返回 true）和自有（Object.hasOwnProperty()返回 true）属性），`它会使用源对象上的[[Get]]取得属性的值，然后使用目标对象上的[[Set]]设置属性的值`。

它是浅复制，多个源对象有相同属性，使用最后一个。

### 对象标识及相等判定

```js
console.log(Object.is(true, 1)); // false
console.log(Object.is({}, {})); // false
console.log(Object.is('2', 2)); // false
// 正确的 0、-0、+0 相等/不等判定
console.log(Object.is(+0, -0)); // false
console.log(Object.is(+0, 0)); // true
console.log(Object.is(-0, 0)); // false
// 正确的 NaN 相等判定
console.log(Object.is(NaN, NaN)); // true
```

### 增强的对象语法

1. 属性值简写

```js
let name = 'Matt';
let person = {
  name,
};
console.log(person); // { name: 'Matt' }
```

2. 计算属性名

```js
let nameKey = 'name';
let person = {
  [nameKey]: 'Matt',
};
console.log(person); // { name: 'Matt' }
```

3. 简写方法名

```js
const methodKey = 'sayName';
let person = {
  [methodKey](name) {
    console.log(`My name is ${name}`);
  },
};
person.sayName('Matt'); // My name is Matt
```

### 对象结构

```js
let person = {
  name: 'Matt',
  age: 27,
};
let { name, job = 'Software engineer' } = person;
console.log(name); // Matt
console.log(job); // Software engineer
```

结构在内部使用函数 ToObject()（不能在运行时环境中直接访问）把源数据结构转换为对象。意味着在对象解构的上下文中，原始值会被当成对象。这也意味着（根据 ToObject()的定义），`null 和 undefined 不能被解构，否则会抛出错误`。

1. 嵌套结构

```js
let person = {
  name: 'Matt',
  age: 27,
  job: {
    title: 'Software engineer',
  },
};
// 声明 title 变量并将 person.job.title 的值赋给它
let {
  job: { title },
} = person;
console.log(title); // Software engineer
```

2. 部分结构

涉及多个属性的解构赋值是一个输出无关的顺序化操作

```js
let person = {
  name: 'Matt',
  age: 27,
};
let personName, personBar, personAge;

try {
  // person.foo 是 undefined，因此会抛出错误
  ({
    name: personName,
    foo: { bar: personBar },
    age: personAge,
  } = person);
} catch (e) {}
console.log(personName, personBar, personAge);
// Matt, undefined, undefined
```

3. 参数上下文匹配

```js
let person = {
  name: 'Matt',
  age: 27,
};
function printPerson(foo, { name, age }, bar) {
  console.log(arguments);
  console.log(name, age);
}
function printPerson2(foo, { name: personName, age: personAge }, bar) {
  console.log(arguments);
  console.log(personName, personAge);
}
printPerson('1st', person, '2nd');
// ['1st', { name: 'Matt', age: 27 }, '2nd']
// 'Matt', 27
printPerson2('1st', person, '2nd');
// ['1st', { name: 'Matt', age: 27 }, '2nd']
// 'Matt', 27
```
